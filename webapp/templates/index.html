<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TradingAgents</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/static/styles.css">
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>
    <!-- Lightweight Markdown renderer for report/messages content -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css" integrity="sha384-zT5nG4Q8nHqvP4YH1Lx3cJ4iAfDdc0AGJi/7luWGINuD/7/UZ5EKeosFVJeI3I2y" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js" integrity="sha384-7il2PASi6DPd7OJbRRqtD9h5pz2jdK5Zk90un0nLBKBPXn1HULICwhf66A1Vpzwu" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQIadC0h8dwF5EYh3QnqTP0TO+GfY+3CX6TtGZVvZ1tcHTfbvZW8FU7c7W0" crossorigin="anonymous"></script>
</head>
<body>
    <div id="overall-progress-container">
        <div id="overall-progress-bar" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100"></div>
    </div>
    <div id="main-content">
    <div id="left-panel" class="layout-left">
            <div id="config-header" class="config-header">
                <h2 style="display:inline-block; margin:0;">Configuration</h2>
                <button id="config-toggle" type="button" class="config-toggle-btn" aria-expanded="true" aria-controls="config-form" onclick="toggleConfigPanel()">Hide</button>
            </div>
            <div id="config-form" class="config-open">
                <h3 style="margin-top:0;">Multi-Run Configuration</h3>
                <form id="multi-run-form" onsubmit="startMultiRun(event)">
                    <label for="multi_company_symbols">Company Symbols (CSV):</label>
                    <input type="text" id="multi_company_symbols" name="company_symbols" placeholder="AAPL,MSFT,NVDA" value="AAPL,MSFT" required>
                    <div class="two-col" style="display:grid; grid-template-columns:1fr 1fr; gap:10px;">
                        <div>
                            <label for="multi_llm_provider">LLM Provider:</label>
                            <select id="multi_llm_provider" name="llm_provider" onchange="updateMultiModelOptions()"></select>
                        </div>
                        <div>
                            <label for="multi_max_debate_rounds">Max Debate Rounds:</label>
                            <select id="multi_max_debate_rounds" name="max_debate_rounds">
                                <option value="1" selected>1</option>
                                <option value="2">2</option>
                                <option value="3">3</option>
                            </select>
                        </div>
                    </div>
                    <label for="multi_quick_think_llm">Quick Think LLM:</label>
                    <select id="multi_quick_think_llm" name="quick_think_llm"></select>
                    <label for="multi_deep_think_llm">Deep Think LLM:</label>
                    <select id="multi_deep_think_llm" name="deep_think_llm"></select>
                    <label for="multi_cost_per_trade">Cost Per Trade ($):</label>
                    <input type="number" id="multi_cost_per_trade" name="cost_per_trade" value="2.0" step="0.1" min="0" required>
                    <label for="multi_analysis_date">Analysis Date:</label>
                    <input type="date" id="multi_analysis_date" name="analysis_date" required>
                    <button type="submit">Start Multi-Run</button>
                    <small style="display:block;margin-top:6px;color:var(--text-secondary);">Requires ENABLE_MULTI_RUN=1 on server.</small>
                </form>
            </div>
                        <div id="execution-tree-container">
                                <div class="instruments-header" style="display:flex; align-items:center; justify-content:space-between; margin-top:0.5rem;">
                                    <strong>Instruments</strong>
                                    <div>
                                        <button type="button" class="small-btn" onclick="openLogFilterModal()">Filter Logs</button>
                                    </div>
                                </div>
                                <div id="instrument-tabs" class="instrument-tabs" role="tablist" aria-label="Instrument Executions"></div>
                                <div id="instrument-trees" class="instrument-trees"></div>
                                <dialog id="log-filter-modal">
                                    <form method="dialog" class="log-filter-form" onsubmit="applyLogFilters(event)">
                                        <h3 style="margin-top:0;">Log Filters</h3>
                                        <label>Severity
                                            <select id="global-log-severity">
                                                <option value="INFO">INFO+</option>
                                                <option value="DEBUG">DEBUG+</option>
                                                <option value="WARN">WARN+</option>
                                                <option value="ERROR">ERROR</option>
                                            </select>
                                        </label>
                                        <label>Sources
                                            <select id="global-log-sources" multiple size="5" style="min-width:140px;">
                                                <option value="agent">agent</option>
                                                <option value="decision">decision</option>
                                                <option value="llm">llm</option>
                                                <option value="tool">tool</option>
                                                <option value="system">system</option>
                                            </select>
                                        </label>
                                        <label>Search
                                            <input type="text" id="global-log-query" placeholder="text..." />
                                        </label>
                                        <div style="display:flex; gap:8px; margin-top:10px;">
                                            <button value="apply" class="primary">Apply</button>
                                            <button value="cancel">Cancel</button>
                                        </div>
                                    </form>
                                </dialog>
                        </div>
        </div>
        <div id="right-panel" class="content-panel">
            <div class="placeholder"><p>Select a phase, agent, messages, or report to view details.</p></div>
        </div>
    </div>
    
    <script>
        // =============================
        // Real-time WebSocket Handling
        // =============================
        let ws = null;
        let wsConnected = false;
        let manualPollingFallback = false; // set true if websocket fails
        let reconnectAttempts = 0;
        const maxReconnectDelay = 15000;

        function websocketUrl(runId=null, opts={}) {
            const proto = window.location.protocol === 'https:' ? 'wss' : 'ws';
            const base = proto + '://' + window.location.host + '/ws';
            const params = [];
            if (runId) params.push('run_id=' + encodeURIComponent(runId));
            if (opts.patch) params.push('patch=1');
            if (params.length) return base + '?' + params.join('&');
            return base;
        }

        function connectWebSocket(runId=null, onMessageCb=null, options={}) {
            try {
                ws = new WebSocket(websocketUrl(runId, options));
            } catch (e) {
                console.warn('[ws] construction failed', e);
                enablePollingFallback();
                return;
            }

            ws.addEventListener('open', () => {
                wsConnected = true;
                reconnectAttempts = 0;
                console.debug('[ws] connected');
                // Stop polling if running
                stopTargetedUpdates();
            });

            ws.addEventListener('close', () => {
                wsConnected = false;
                console.debug('[ws] closed');
                if (!manualPollingFallback) scheduleReconnect();
                else startTargetedUpdates();
            });

            ws.addEventListener('error', (err) => {
                console.warn('[ws] error', err);
            });

            ws.addEventListener('message', (event) => {
                let data;
                try { data = JSON.parse(event.data); } catch { return; }
                if (onMessageCb) { onMessageCb(data); }
                if (data.type === 'init') {
                    if (data.execution_tree_html) injectExecutionTree(data.execution_tree_html, data);
                } else if (data.type === 'status_update') {
                    applyStatusUpdate(data);
                } else if (data.type === 'init_all') {
                    // Aggregate init for multi-run: populate any existing runs into tabs
                    ensureMultiRunVisible();
                    // If execution tree not yet injected (empty container), attempt injection from payload if provided
                    if (data.execution_tree_html) {
                        injectExecutionTree(data.execution_tree_html, data);
                    } else {
                        const container = document.getElementById('execution-tree-container');
                        if (container && container.children.length === 0) {
                            // fallback fetch of status partial
                            fetch('/status').then(r=>r.text()).then(html => injectExecutionTree(html, {})).catch(()=>{});
                        }
                    }
                    if (Array.isArray(data.runs)) {
                        data.runs.forEach(r => ensureRunTab(r.run_id, r.ticker, r.status));
                    }
                } else if (data.type === 'status_update_aggregate') {
                    if (data.runs) {
                        Object.entries(data.runs).forEach(([rid, rinfo]) => {
                            updateRunTab(rid, rinfo.status, rinfo.overall_progress);
                        });
                    }
                } else if (data.type === 'init_run') {
                    // Focused snapshot load (populate tree in left panel)
                    loadRunTree(data.run_id, data);
                    if (data.patches) {
                        if (!window.runPatchState) window.runPatchState = {};
                        window.runPatchState[data.run_id] = { seq: data.seq || 0 };
                        console.debug('[patch] enabled for run', data.run_id, 'seq=0');
                    }
                    if (data.log_stream) {
                        ensureRunLogElements(data.run_id);
                        if (!window.runLogState) window.runLogState = {};
                        window.runLogState[data.run_id] = { seq: 0, syncing: false };
                        try { ws.send(JSON.stringify({action:'log_dump', run_id: data.run_id})); } catch {}
                    }
                } else if (data.type === 'status_patch_run') {
                    applyRunPatch(data);
                } else if (data.type === 'status_update_run') {
                    updateRunTab(data.run_id, data.status, data.overall_progress);
                    // Optionally update panel progress if open
                    const p = document.querySelector(`#panel-${CSS.escape(data.run_id)} .run-progress-inner`);
                    if (p && typeof data.overall_progress === 'number') {
                        p.style.width = data.overall_progress + '%';
                    }
                    if (data.decision_html) {
                        const dec = document.getElementById(`decision-${data.run_id}`);
                        if (dec) {
                            dec.innerHTML = data.decision_html;
                        }
                    }
                } else if (data.type === 'run_snapshot') {
                    // Full snapshot after resync. Rebuild tree & reset patch tracking sequence.
                    loadRunTree(data.run_id, data);
                    if (!window.runPatchState) window.runPatchState = {};
                    window.runPatchState[data.run_id] = { seq: data.seq || 0 };
                        panel.innerHTML = `<div class=\"right-panel-inner\"><div class=\"content-header\"><h3>${itemId.replace(/_(messages|report)$/,'')} ${itemId.endsWith('_messages')?'Messages':'Report'}</h3></div><div class=\"content-body\">${cached ? cached : '<em>Streaming...</em>'}</div></div>`;
                        // If cached already contains math delimiters, schedule render (stream patches also trigger renders)
                        if (cached) {
                            const bodyEl = panel.querySelector('.content-body');
                            if (bodyEl && contentHasRenderableMath(bodyEl.textContent)) scheduleMathRender(bodyEl);
                        }
                } else if (data.type === 'log_append_run') {
                    handleRunLogAppend(data);
                } else if (data.type === 'log_snapshot_run') {
                    handleRunLogSnapshot(data);
                } else if (data.type === 'content') {
                    // Content panel update
                    const right = document.getElementById('right-panel');
                    if (right) {
                        right.innerHTML = data.html;
                    }
                }
            });
        }

        function scheduleReconnect() {
            reconnectAttempts += 1;
            const delay = Math.min(1000 * Math.pow(2, reconnectAttempts), maxReconnectDelay);
            console.debug('[ws] reconnect in', delay);
            setTimeout(() => {
                if (!wsConnected) connectWebSocket();
            }, delay);
            // Meanwhile start fallback polling after a short grace
            if (!manualPollingFallback) {
                setTimeout(() => {
                    if (!wsConnected) enablePollingFallback();
                }, 2500);
            }
        }

        function enablePollingFallback() {
            if (manualPollingFallback) return; // already enabled
            manualPollingFallback = true;
            console.debug('[fallback] enabling polling');
            startTargetedUpdates();
        }

        function applyStatusUpdate(data) {
            if (!data) return;
            updateOverallProgress(data.overall_progress, data.overall_status);
            const updates = data.status_updates || {};
            for (const [itemId, statusInfo] of Object.entries(updates)) {
                const statusIcon = document.querySelector(`[hx-get="/content/${itemId}"] .status-icon`);
                if (statusIcon && statusIcon.textContent !== statusInfo.status_icon) {
                    statusIcon.textContent = statusInfo.status_icon;
                    const processItem = statusIcon.closest('.process-item');
                    if (processItem) {
                        processItem.classList.remove('status-pending', 'status-in_progress', 'status-completed', 'status-error');
                        processItem.classList.add('status-' + statusInfo.status);
                    }
                }
            }
        }

        function updateOverallProgress(progress, status) {
            const progressBar = document.getElementById('overall-progress-bar');
            const progressText = document.getElementById('overall-progress-text');
            if (progressBar && typeof progress === 'number') progressBar.style.width = progress + '%';
            if (progressText) progressText.textContent = progress + '% (' + status + ')';
        }
        // Populated dynamically from /config/providers
        let modelOptions = {};
        let providerDisplayNames = {};

        async function fetchProviderConfig() {
            try {
                const resp = await fetch('/config/providers');
                const data = await resp.json();
                const providers = data.providers || [];
                const providerSelect = document.getElementById('multi_llm_provider');
                providerSelect.innerHTML = '';
                providers.forEach(p => {
                    providerDisplayNames[p.key] = p.display_name || p.key;
                    modelOptions[p.key] = p.models || {};
                    const opt = document.createElement('option');
                    opt.value = p.key;
                    opt.textContent = p.display_name || p.key;
                    if (p.key === 'openrouter') opt.selected = true;
                    providerSelect.appendChild(opt);
                });
                updateMultiModelOptions();
            } catch (e) {
                console.error('Failed to load provider configuration', e);
            }
        }

        function updateMultiModelOptions() {
        // =============================
        // Config Collapse & Tree Injection
        // =============================
        function toggleConfigPanel(forceState=null) {
            const formWrap = document.getElementById('config-form');
            const btn = document.getElementById('config-toggle');
            if (!formWrap || !btn) return;
            const isOpen = formWrap.classList.contains('config-open');
            const willOpen = forceState === null ? !isOpen : forceState;
            formWrap.classList.toggle('config-open', willOpen);
            formWrap.classList.toggle('config-collapsed', !willOpen);
            btn.textContent = willOpen ? 'Hide' : 'Show';
            btn.setAttribute('aria-expanded', String(willOpen));
        }

        function collapseConfigAfterStart() {
            toggleConfigPanel(false);
        }

        function injectExecutionTree(html, meta) {
            try {
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                const treeEl = doc.querySelector('.execution-tree');
                const container = document.getElementById('execution-tree-container');
                if (treeEl && container) {
                    container.innerHTML = '';
                    container.appendChild(treeEl);
                }
                if (meta && typeof meta.overall_progress === 'number') {
                    updateOverallProgress(meta.overall_progress, meta.overall_status);
                }
            } catch(e) { console.warn('Tree inject failed', e); }
        }

        // Override startMultiRun to collapse config on success
        const originalStartMultiRun = window.startMultiRun;
        window.startMultiRun = function(e) {
            originalStartMultiRun(e);
            // collapse shortly after submission (optimistic)
            setTimeout(collapseConfigAfterStart, 400);
            // fetch latest status partial to seed left tree if not present
            setTimeout(() => {
                const container = document.getElementById('execution-tree-container');
                if (container && container.children.length === 0) {
                    fetch('/status').then(r=>r.text()).then(html => injectExecutionTree(html, {})).catch(()=>{});
                }
            }, 800);
        }
            const providerEl = document.getElementById('multi_llm_provider');
            if (!providerEl) return;
            const provider = providerEl.value;
            const quickSelect = document.getElementById('multi_quick_think_llm');
            const deepSelect = document.getElementById('multi_deep_think_llm');
            if (!quickSelect || !deepSelect) return;
            quickSelect.innerHTML = '';
            deepSelect.innerHTML = '';
            const quickList = (modelOptions[provider] && modelOptions[provider].quick) || [];
            quickList.forEach(m => {
                const option = document.createElement('option');
                option.value = m.id || m.value || m;
                option.textContent = m.name || m.text || option.value;
                quickSelect.appendChild(option);
            });
            const deepList = (modelOptions[provider] && modelOptions[provider].deep) || [];
            deepList.forEach(m => {
                const option = document.createElement('option');
                option.value = m.id || m.value || m;
                option.textContent = m.name || m.text || option.value;
                deepSelect.appendChild(option);
            });
        }

        // Position fields removed in multi-run only UI

        // Set current date as default for analysis_date
        function setCurrentDate() {
            const el = document.getElementById('analysis_date');
            if (el && !el.value) { // only set if not already provided by server
                const today = new Date();
                const dateString = today.toISOString().split('T')[0];
                el.value = dateString;
            }
        }

    // Toggle node functionality for collapsible tree
        function toggleNode(button) {
            const li = button.closest('li.process-item');
            const children = li ? li.querySelector(':scope > .item-children') : null;
            if (!children) return;
            const isExpanded = children.classList.contains('expanded');
            if (isExpanded) {
                children.classList.remove('expanded');
                children.classList.add('collapsed');
                button.classList.remove('expanded');
                button.setAttribute('aria-expanded', 'false');
            } else {
                children.classList.remove('collapsed');
                children.classList.add('expanded');
                button.classList.add('expanded');
                button.setAttribute('aria-expanded', 'true');
            }
    }

    // Initial fetch of provider config
    fetchProviderConfig();

        // Save the current expansion state of all toggleable items
        function saveExpansionState() {
            const state = {};
            const executionTree = document.querySelector('.execution-tree');
            if (executionTree) {
                const items = executionTree.querySelectorAll('.process-item');
                items.forEach(item => {
                    const children = item.querySelector('.item-children');
                    const button = item.querySelector('.toggle-btn');
                    if (children && button) {
                        const itemId = getItemId(item);
                        if (itemId) {
                            state[itemId] = children.classList.contains('expanded');
                        }
                    }
                });
            }
            return state;
        }

        // Restore the expansion state after content update
        function restoreExpansionState(savedState) {
            if (!savedState) return;
            
            const executionTree = document.querySelector('.execution-tree');
            if (executionTree) {
                const items = executionTree.querySelectorAll('.process-item');
                items.forEach(item => {
                    const children = item.querySelector('.item-children');
                    const button = item.querySelector('.toggle-btn');
                    if (children && button) {
                        const itemId = getItemId(item);
                        if (itemId && savedState.hasOwnProperty(itemId)) {
                            if (savedState[itemId]) {
                                // Expand
                                children.classList.remove('collapsed');
                                children.classList.add('expanded');
                                button.classList.add('expanded');
                            } else {
                                // Collapse
                                children.classList.remove('expanded');
                                children.classList.add('collapsed');
                                button.classList.remove('expanded');
                            }
                        }
                    }
                });
            }
        }

        // Get item ID from the clickable span
        function getItemId(processItem) {
            const clickableSpan = processItem.querySelector('.item-name.clickable');
            if (clickableSpan) {
                const hxGet = clickableSpan.getAttribute('hx-get');
                if (hxGet) {
                    const match = hxGet.match(/\/content\/(.+)$/);
                    return match ? match[1] : null;
                }
            }
            return null;
        }

        // Handle HTMX before request to save state
        document.addEventListener('htmx:beforeSwap', function(event) {
                if (event.target.id === 'left-panel') {
                window.savedExpansionState = saveExpansionState();
            }
        });

        // Handle HTMX after settle to restore state
            document.addEventListener('htmx:afterSettle', function(event) {
                if (event.target.id === 'left-panel' && window.savedExpansionState) {
                restoreExpansionState(window.savedExpansionState);
            }
        });

        // Targeted status updates to prevent flickering
        function updateStatusIndicators() {
            // Fallback polling (legacy)
            if (wsConnected) return; // skip if websocket active
            fetch('/status-updates')
              .then(r => r.json())
              .then(data => applyStatusUpdate({
                status_updates: data.status_updates,
                overall_progress: data.overall_progress,
                overall_status: data.overall_status
              }))
              .catch(err => console.log('Status update failed:', err));
        }

        // Start targeted updates when execution tree is present
        function startTargetedUpdates() {
            const tree = document.querySelector('.execution-tree');
            if (!tree) return;
            if (!window.statusUpdateInterval) {
                console.debug('[status] starting interval');
                window.statusUpdateInterval = setInterval(updateStatusIndicators, 2000);
            }
        }

        // Stop targeted updates
        function stopTargetedUpdates() {
            if (window.statusUpdateInterval) {
                clearInterval(window.statusUpdateInterval);
                window.statusUpdateInterval = null;
            }
        }

        // Initialize the page
        document.addEventListener('DOMContentLoaded', function() {
            // Set today's date as default for multi-run if empty
            try {
                const today = new Date();
                const iso = today.toISOString().split('T')[0];
                const multiDate = document.getElementById('multi_analysis_date');
                if (multiDate && !multiDate.value) multiDate.value = iso;
            } catch(e) { console.warn('Date init failed', e); }
            // Load provider config then establish websocket
            fetchProviderConfig().finally(() => {
                connectWebSocket();
                setTimeout(() => { if (!wsConnected) startTargetedUpdates(); }, 1200);
            });
        });

        /* =============================
           Multi-Run UI Helpers
        ============================= */
        // Removed syncMultiModelOptions (single-run mode deprecated)

        function ensureMultiRunVisible() {
            // Now a no-op (UI relocated to left panel)
            return true;
        }

        function ensureRunTab(runId, ticker, status) {
            // Create instrument tab button on left panel
            let tab = document.getElementById('instrument-tab-' + runId);
            if (!tab) {
                const tabs = document.getElementById('instrument-tabs');
                if (!tabs) return;
                tab = document.createElement('button');
                tab.id = 'instrument-tab-' + runId;
                tab.className = 'instrument-tab';
                tab.setAttribute('role','tab');
                tab.dataset.runId = runId;
                tab.textContent = ticker + ' (' + status + ')';
                tab.addEventListener('click', () => activateRun(runId));
                tabs.appendChild(tab);
                // Container for that run's tree
                const treesHost = document.getElementById('instrument-trees');
                const treeWrap = document.createElement('div');
                treeWrap.id = 'instrument-tree-' + runId;
                treeWrap.className = 'instrument-tree-wrapper';
                treeWrap.innerHTML = `<div class="run-progress"><div class="run-progress-inner" style="width:0%"></div></div><ul class="execution-tree" data-run-tree="${runId}"><li><em>Initializing...</em></li></ul>`;
                treesHost.appendChild(treeWrap);
            }
            updateRunTab(runId, status);
        }

        function updateRunTab(runId, status, progress=null) {
            const tab = document.getElementById('instrument-tab-' + runId);
            if (tab) {
                const current = tab.textContent;
                tab.textContent = current.replace(/\([^)]*\)$/,'(' + status + ')');
                tab.dataset.status = status;
            }
            if (progress != null) {
                const prog = document.querySelector(`#instrument-tree-${CSS.escape(runId)} .run-progress-inner`);
                if (prog) prog.style.width = progress + '%';
            }
        }

        function activateRun(runId) {
            document.querySelectorAll('.instrument-tab').forEach(t=> t.classList.toggle('active', t.dataset.runId === runId));
            document.querySelectorAll('.instrument-tree-wrapper').forEach(w=> w.style.display = (w.id === 'instrument-tree-' + runId) ? 'block' : 'none');
            const treeWrap = document.getElementById('instrument-tree-' + runId);
            if (treeWrap && !treeWrap.dataset.focused) {
                connectWebSocket(runId, (msg) => {
                    if (msg.type === 'init_run') loadRunTree(runId, msg);
                    else if (msg.type === 'status_update_run') updateRunTab(runId, msg.status, msg.overall_progress);
                    else if (msg.type === 'status_patch_run') applyRunPatch(msg);
                    else if (msg.type === 'content_patch_run') applyContentPatches(msg);
                    else if (msg.type === 'log_append_run') handleRunLogAppend(msg);
                    else if (msg.type === 'log_snapshot_run') handleRunLogSnapshot(msg);
                }, {patch: true});
                treeWrap.dataset.focused = '1';
            }
        }

        function loadRunTree(runId, snapshot) {
            const wrapper = document.querySelector(`#instrument-tree-${CSS.escape(runId)} ul.execution-tree`);
            if (!wrapper) return;
            if (snapshot.execution_tree) {
                wrapper.innerHTML = '';
                snapshot.execution_tree.forEach(phase => {
                    const li = document.createElement('li');
                    li.id = `run-${runId}-node-${phase.id}`;
                    li.className = 'process-item phase-node status-' + phase.status;
                    li.innerHTML = `<div class="item-header"><button class="toggle-btn" onclick="toggleNode(this)"><span class="toggle-icon">▶</span></button><span class="item-name clickable" data-item-id="${phase.id}" onclick="selectNode(event,'${phase.id}','${runId}')"><span class="status-icon">${statusIconFor(phase.status)}</span>${phase.name}</span></div><ul class="item-children collapsed"></ul>`;
                    const childrenUl = li.querySelector('.item-children');
                    (phase.children||[]).forEach(agent => {
                        const agentLi = document.createElement('li');
                        agentLi.id = `run-${runId}-node-${agent.id}`;
                        agentLi.className = 'process-item agent-node status-' + agent.status;
                        agentLi.innerHTML = `<div class="item-header"><button class="toggle-btn" onclick="toggleNode(this)"><span class="toggle-icon">▶</span></button><span class="item-name clickable" data-item-id="${agent.id}" onclick="selectNode(event,'${agent.id}','${runId}')"><span class="status-icon">${statusIconFor(agent.status)}</span>${agent.name}</span></div><ul class="item-children collapsed"></ul>`;
                        const childUl = agentLi.querySelector('.item-children');
                        (agent.children||[]).forEach(child => {
                            const childLi = document.createElement('li');
                            childLi.id = `run-${runId}-node-${child.id}`;
                            childLi.className = 'process-item leaf-node status-' + child.status;
                            // Name provided by backend already contains emoji (e.g. 💬 / 📄)
                            childLi.innerHTML = `<div class=\"item-header\"><span class=\"toggle-spacer\"></span><span class=\"item-name clickable\" data-item-id=\"${child.id}\" onclick=\"selectNode(event,'${child.id}','${runId}')\"><span class=\"status-icon\">${statusIconFor(child.status)}</span>${child.name}</span></div>`;
                            childUl.appendChild(childLi);
                        });
                        childrenUl.appendChild(agentLi);
                    });
                    wrapper.appendChild(li);
                });
            }
            if (snapshot.log_stream) ensureRunLogElements(runId);
        }

        function statusIconFor(status) {
            if (status === 'completed') return '✅';
            if (status === 'in_progress') return '⏳';
            if (status === 'error') return '❌';
            return '⏸️';
        }

        // ---------------- Global Content Patch Handling ----------------
        if (!window.runContentState) window.runContentState = {}; // run_id -> { seq, nodes }
        // Heuristic: decide if raw content should be treated as markdown (simple check)
        function isLikelyMarkdown(text) {
            if (!text) return false;
            // If already contains HTML block tags, assume it's already rendered
            if (/<(p|h1|h2|h3|ul|ol|table|div|section|article)\b/i.test(text)) return false;
            // Presence of markdown syntax characters
            return /(^|\n)#{1,6}\s|\*\*|`{1,3}[^`]|\n[-*+]\s|\n\d+\.\s/.test(text);
        }

        function renderContentForItem(itemId, raw) {
            if (!raw) return '';
            const isReport = /_report$/.test(itemId);
            const isMessages = /_messages$/.test(itemId);
            // Treat both reports and messages as markdown-capable. For messages we still skip if clearly plain.
            if (isReport || isMessages || isLikelyMarkdown(raw)) {
                try {
                    return marked.parse(raw, { breaks: true });
                } catch (e) {
                    console.warn('[markdown] render failed, falling back to plain text', e);
                    return raw.replace(/[&<>]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;'}[c]));
                }
            }
            return raw;
        }

        function contentHasRenderableMath(str) {
            if (!str) return false;
            // Look for balanced $$...$$ or inline $...$ (simple heuristics)
            if (/\$\$[\s\S]*?\$\$/m.test(str)) return true;
            // Inline math: ensure at least one pair of single dollars with content inside (avoid currency like $10)
            const inlineMatches = str.match(/\$(?!\s)([^\n$]{1,80}?)\$/g); // small-ish inline segments
            return inlineMatches && inlineMatches.length > 0;
        }

        function scheduleMathRender(rootEl) {
            if (!rootEl) return;
            // Avoid re-render storms; only proceed if KaTeX loaded and there is unprocessed math
            if (!window.renderMathInElement) {
                // Retry shortly until scripts load
                setTimeout(() => scheduleMathRender(rootEl), 150);
                return;
            }
            // If already contains rendered katex nodes and no new delimiters, skip
            const textContent = rootEl.textContent || '';
            if (!contentHasRenderableMath(textContent)) return;
            try {
                window.renderMathInElement(rootEl, {
                    delimiters: [
                        {left: '$$', right: '$$', display: true},
                        {left: '$', right: '$', display: false},
                        {left: '\\(', right: '\\)', display: false},
                        {left: '\\[', right: '\\]', display: true}
                    ],
                    throwOnError: false,
                    strict: 'ignore'
                });
            } catch (e) {
                console.warn('[math] render failed', e);
            }
        }

        function applyContentPatches(msg) {
            const { run_id, seq, patches } = msg;
            if (!window.runContentState[run_id]) window.runContentState[run_id] = { seq: 0, nodes: {} };
            const state = window.runContentState[run_id];
            if (seq <= state.seq) return;
            if (seq !== state.seq + 1) {
                console.warn('[content-patch] sequence gap, requesting resync', run_id);
                try { ws && ws.send(JSON.stringify({action: 'resync', run_id})); } catch {}
                return;
            }
            patches.forEach(p => {
                const existing = state.nodes[p.id] || '';
                if (p.mode === 'append') state.nodes[p.id] = existing + (p.text || '');
                else if (p.mode === 'replace') state.nodes[p.id] = p.content || '';
                // Render markdown if applicable (store rendered HTML separately?)
                const rendered = renderContentForItem(p.id, state.nodes[p.id]);
                const panel = document.getElementById('right-panel');
                if (panel && panel.dataset.currentItemId === p.id) {
                    const body = panel.querySelector('.content-body');
                    if (body) {
                        body.innerHTML = rendered;
                        // After inserting, attempt math render if needed
                        if (contentHasRenderableMath(state.nodes[p.id])) {
                            scheduleMathRender(body);
                        }
                    }
                }
                // Replace stored node with rendered HTML for display consistency
                state.nodes[p.id] = rendered;
            });
            state.seq = seq;
        }

        function applyRunPatch(patchMsg) {
            const { run_id, seq, changed } = patchMsg;
            if (!window.runPatchState || !window.runPatchState[run_id]) {
                console.debug('[patch] ignoring patch for untracked run', run_id);
                return;
            }
            const state = window.runPatchState[run_id];
            if (state.syncing) {
                // Ignore incremental patches while awaiting a full resync snapshot
                return;
            }
            if (seq <= state.seq) {
                // Stale or duplicate
                return;
            }
            if (seq !== state.seq + 1) {
                console.warn('[patch] sequence gap detected run', run_id, 'expected', state.seq + 1, 'got', seq, '-> requesting resync');
                state.syncing = true;
                try {
                    ws && ws.readyState === WebSocket.OPEN && ws.send(JSON.stringify({action: 'resync', run_id}));
                } catch (e) {
                    console.warn('[patch] resync request failed', e);
                }
                return;
            }
            changed.forEach(node => {
                const el = document.getElementById(`run-${run_id}-node-${node.id}`);
                if (el) {
                    el.classList.remove('status-pending','status-in_progress','status-completed','status-error');
                    el.classList.add('status-' + node.status);
                    const iconSpan = el.querySelector('.status-icon');
                    if (iconSpan) {
                        const desired = (node.status_icon && node.status_icon.trim()) ? node.status_icon : statusIconFor(node.status);
                        if (iconSpan.textContent !== desired) iconSpan.textContent = desired;
                    }
                }
                // Propagate to synthetic (or real) leaves if they exist
                ['messages','report'].forEach(kind => {
                    const leafEl = document.getElementById(`run-${run_id}-node-${node.id}_${kind}`);
                    if (leafEl) {
                        leafEl.classList.remove('status-pending','status-in_progress','status-completed','status-error');
                        leafEl.classList.add('status-' + node.status);
                        const leafIcon = leafEl.querySelector('.status-icon');
                        if (leafIcon) {
                            const leafDesired = (node.status_icon && node.status_icon.trim()) ? node.status_icon : statusIconFor(node.status);
                            if (leafIcon.textContent !== leafDesired) leafIcon.textContent = leafDesired;
                        }
                    }
                });
            });
            state.seq = seq;
            // Update progress bar in panel if provided
            if (typeof patchMsg.overall_progress === 'number') {
                const p = document.querySelector(`#panel-${CSS.escape(run_id)} .run-progress-inner`);
                if (p) p.style.width = patchMsg.overall_progress + '%';
            }
        }

        // =============================
        // Log Streaming UI & Handlers
        // =============================
        function ensureRunLogElements(runId) {
            const panel = document.getElementById('panel-' + runId);
            if (!panel) return;
            let logWrap = panel.querySelector('.run-log-wrapper');
            if (!logWrap) {
                logWrap = document.createElement('div');
                logWrap.className = 'run-log-wrapper';
                logWrap.innerHTML = `<details open style="margin-top:8px;">
                    <summary style="cursor:pointer;">Live Log & Filters</summary>
                    <div class="run-log-filters" style="display:flex; gap:6px; flex-wrap:wrap; align-items:center; margin-bottom:4px;">
                        <label style="font-size:11px;">Severity:
                          <select data-log-sev="${runId}" style="font-size:11px;">
                            <option value="INFO" selected>INFO+</option>
                            <option value="DEBUG">DEBUG+</option>
                            <option value="WARN">WARN+</option>
                            <option value="ERROR">ERROR</option>
                          </select>
                        </label>
                        <label style="font-size:11px;">Source:
                          <select data-log-src="${runId}" multiple size="1" style="font-size:11px; min-width:90px;">
                            <option value="agent">agent</option>
                            <option value="decision">decision</option>
                            <option value="llm">llm</option>
                            <option value="tool">tool</option>
                            <option value="system">system</option>
                          </select>
                        </label>
                        <input data-log-q="${runId}" type="text" placeholder="search..." style="font-size:11px; padding:2px 4px;" />
                        <button type="button" data-log-refresh="${runId}" style="font-size:11px;">Reload</button>
                        <a href="/runs/${runId}/logs/download" target="_blank" style="font-size:11px; text-decoration:none;">Download</a>
                        <span id="log-meta-${runId}" style="font-size:10px; opacity:0.6;">seq:0</span>
                    </div>
                    <div class="run-log" id="log-${runId}" style="background:#111; border:1px solid var(--border-color); padding:6px; font-family:monospace; font-size:12px; max-height:180px; overflow:auto; white-space:pre; line-height:1.2;"></div>
                </details>`;
                panel.appendChild(logWrap);
                attachLogFilterEvents(runId);
            }
        }

        function attachLogFilterEvents(runId) {
            const sevSel = document.querySelector(`select[data-log-sev='${runId}']`);
            const srcSel = document.querySelector(`select[data-log-src='${runId}']`);
            const qInput = document.querySelector(`input[data-log-q='${runId}']`);
            const reloadBtn = document.querySelector(`button[data-log-refresh='${runId}']`);
            if (sevSel) sevSel.addEventListener('change', () => reloadLogs(runId, true));
            if (srcSel) srcSel.addEventListener('change', () => reloadLogs(runId, true));
            if (qInput) qInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') reloadLogs(runId, true); });
            if (reloadBtn) reloadBtn.addEventListener('click', () => reloadLogs(runId, true));
        }

        function currentLogFilter(runId) {
            const sevSel = document.querySelector(`select[data-log-sev='${runId}']`);
            const srcSel = document.querySelector(`select[data-log-src='${runId}']`);
            const qInput = document.querySelector(`input[data-log-q='${runId}']`);
            let severity = sevSel ? sevSel.value : 'INFO';
            const selectedSources = [];
            if (srcSel) Array.from(srcSel.selectedOptions).forEach(o => selectedSources.push(o.value));
            const q = qInput ? qInput.value.trim() : '';
            return { severity, sources: selectedSources, q };
        }

        function formatLogEntry(entry) {
            const sev = entry.severity || 'INFO';
            const iso = entry.iso || '';
            const src = entry.source || '';
            const agent = entry.agent_id ? `(${entry.agent_id})` : '';
            // Simple color tags via spans; CSS classes handle palette
            return `<div class="log-line sev-${sev}">[${iso}] [${sev}] [${src}]${agent} ${escapeHtml(entry.message||'')}</div>`;
        }

        function escapeHtml(str) {
            return str.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c]));
        }

        function reloadLogs(runId, reset=false) {
            if (!window.runLogState) window.runLogState = {};
            if (!window.runLogState[runId]) window.runLogState[runId] = { seq: 0, syncing: false };
            const st = window.runLogState[runId];
            let after_seq = reset ? null : st.seq;
            const { severity, sources, q } = currentLogFilter(runId);
            const params = new URLSearchParams();
            if (severity) params.set('severity', severity);
            if (sources && sources.length) params.set('sources', sources.join(','));
            if (q) params.set('q', q);
            if (after_seq != null) params.set('after_seq', after_seq);
            params.set('limit', '250');
            fetch(`/runs/${encodeURIComponent(runId)}/logs?` + params.toString())
              .then(r=>r.json())
              .then(js => {
                const el = document.getElementById('log-' + runId);
                if (!el) return;
                if (reset) el.innerHTML='';
                (js.entries||[]).forEach(e => {
                    el.insertAdjacentHTML('beforeend', formatLogEntry(e));
                    st.seq = Math.max(st.seq, e.seq);
                });
                updateLogMeta(runId, st.seq);
                autoScroll(el);
              })
              .catch(()=>{});
        }

        function updateLogMeta(runId, seq) {
            const meta = document.getElementById('log-meta-' + runId);
            if (meta) meta.textContent = 'seq:' + seq;
        }

        function handleRunLogAppend(msg) {
            if (!window.runLogState || !window.runLogState[msg.run_id]) return;
            const st = window.runLogState[msg.run_id];
            if (msg.seq <= st.seq) return;
            if (msg.seq !== st.seq + 1) {
                console.warn('[log] gap detected run', msg.run_id, 'expected', st.seq + 1, 'got', msg.seq, 'requesting dump');
                st.syncing = true;
                try { ws && ws.send(JSON.stringify({action:'log_dump', run_id: msg.run_id})); } catch {}
                return;
            }
            const el = document.getElementById('log-' + msg.run_id);
            if (el) {
                (msg.entries || []).forEach(entry => {
                    el.insertAdjacentHTML('beforeend', formatLogEntry(entry));
                    st.seq = Math.max(st.seq, entry.seq);
                });
                updateLogMeta(msg.run_id, st.seq);
                autoScroll(el);
            } else {
                st.seq = msg.seq;
            }
        }

        function handleRunLogSnapshot(msg) {
            if (!window.runLogState) window.runLogState = {};
            window.runLogState[msg.run_id] = { seq: msg.seq, syncing: false };
            ensureRunLogElements(msg.run_id);
            const el = document.getElementById('log-' + msg.run_id);
            if (el) {
                el.innerHTML='';
                (msg.entries || []).forEach(entry => {
                    el.insertAdjacentHTML('beforeend', formatLogEntry(entry));
                });
                updateLogMeta(msg.run_id, msg.seq);
                autoScroll(el);
            }
        }

        function autoScroll(container) {
            if (!container) return;
            const nearBottom = container.scrollHeight - container.scrollTop - container.clientHeight < 30;
            if (nearBottom) container.scrollTop = container.scrollHeight;
        }

                function cancelRun(runId) {
            fetch(`/runs/${encodeURIComponent(runId)}/cancel`, {method:'POST'})
              .then(r=>r.json())
              .then(js=>{ updateRunTab(runId, 'canceled'); })
              .catch(()=>{});
        }

                function startMultiRun(ev) {
            ev.preventDefault();
            const form = ev.target;
            const fd = new FormData(form);
            ensureMultiRunVisible();
            // Kick off aggregate websocket if not connected yet
            if (!wsConnected) connectWebSocket();
            fetch('/start-multi', {method:'POST', body: fd})
              .then(r=> r.json())
              .then(js => {
                if (js.runs) {
                    js.runs.forEach(r => ensureRunTab(r.run_id, r.ticker, 'in_progress'));
                    // Activate first run automatically
                    if (js.runs.length) activateRun(js.runs[0].run_id);
                } else if (js.error) {
                    alert('Error: ' + js.error);
                }
              })
              .catch(err => console.error('multi-run start failed', err));
        }
                // Selection & Content Fetch
                function selectNode(ev, itemId, runId=null) {
                    ev.stopPropagation();
                    document.querySelectorAll('.item-name.clickable.active').forEach(el=> el.classList.remove('active'));
                    const target = ev.currentTarget;
                    target.classList.add('active');
                    // Derive runId from ancestor tree if not explicitly passed
                    if (!runId) {
                        const tree = target.closest('ul.execution-tree');
                        if (tree && tree.dataset.runTree) runId = tree.dataset.runTree;
                    }
                    const isLeafStream = /(_messages|_report)$/.test(itemId) && runId;
                    const panel = document.getElementById('right-panel');
                    panel.dataset.currentItemId = itemId;
                    if (runId) panel.dataset.currentRunId = runId;
                    if (isLeafStream) {
                        // Render from patch cache immediately (or placeholder)
                        let cached = (window.runContentState && window.runContentState[runId] && window.runContentState[runId].nodes[itemId]) || '';
                        if (cached) {
                            // If cached appears unrendered markdown (e.g., first selection before any patch render pass), render now
                            if (!/<(p|h1|h2|h3|ul|ol|table|code)\b/i.test(cached)) {
                                cached = renderContentForItem(itemId, cached);
                                if (window.runContentState && window.runContentState[runId]) {
                                    window.runContentState[runId].nodes[itemId] = cached;
                                }
                            }
                        }
                        panel.innerHTML = `<div class="right-panel-inner"><div class="content-header"><h3>${itemId.replace(/_(messages|report)$/,'')} ${itemId.endsWith('_messages')?'Messages':'Report'}</h3></div><div class="content-body">${cached ? cached : '<em>Streaming...</em>'}</div></div>`;
                            if (!cached) {
                                // In case patches arrive after selection
                                setTimeout(()=>{ applyContentOverride(runId, itemId); }, 50);
                            }
                    } else {
                        const url = runId ? `/runs/${encodeURIComponent(runId)}/content/${encodeURIComponent(itemId)}` : `/content/${encodeURIComponent(itemId)}`;
                        fetch(url)
                          .then(r=> r.text())
                          .then(html => {
                              panel.innerHTML = html;
                              // If we already have streamed content for this node (e.g., if it also patches), override
                              try { applyContentOverride(runId, itemId); } catch(e) {}
                              // Attempt math rendering on freshly fetched static content
                              const bodyEl = panel.querySelector('.content-body') || panel;
                              if (bodyEl && contentHasRenderableMath(bodyEl.textContent)) scheduleMathRender(bodyEl);
                          })
                          .catch(()=>{});
                    }
                }
                function applyContentOverride(runId, itemId) {
                    if (!runId || !window.runContentState || !window.runContentState[runId]) return;
                    const state = window.runContentState[runId];
                    const content = state.nodes[itemId];
                    if (!content) return;
                    const panel = document.getElementById('right-panel');
                    if (!panel) return;
                    const body = panel.querySelector('.content-body');
                    if (body) {
                        body.innerHTML = content; // already rendered (markdown -> HTML)
                        if (contentHasRenderableMath(body.textContent)) scheduleMathRender(body);
                    }
                }
                // Log Filter Modal
                function openLogFilterModal() { const dlg = document.getElementById('log-filter-modal'); if (dlg) dlg.showModal(); }
                function applyLogFilters(e) { e.preventDefault(); const dlg = document.getElementById('log-filter-modal'); if (dlg) dlg.close(); /* propagate filters to each run reloadLogs later */ }

        // Handle when new content is loaded (like when starting a process)
        document.addEventListener('htmx:afterSettle', function(event) {
                if (event.target.id === 'left-panel') {
                if (window.savedExpansionState) {
                    restoreExpansionState(window.savedExpansionState);
                }
                // If websocket connected, no need to restart polling
                if (!wsConnected) {
                    stopTargetedUpdates();
                    startTargetedUpdates();
                }
            }
        });
    </script>
</body>
</html>
